import numpy as np
from ensemble import cvxpy_solvers, utils


SOLVER_DICT = {
    'reg:mse': cvxpy_solvers.solve_regressor_mse,
    'reg:mae': cvxpy_solvers.solve_regressor_mae,
    'binary:logloss_probs': cvxpy_solvers.solve_binary_logloss_probs,
    'binary:logloss_logits': cvxpy_solvers.solve_binary_logloss_logits,
    'multi:logloss_probs': cvxpy_solvers.solve_multiclass_logloss_probs,
    'multi:logloss_logits': cvxpy_solvers.solve_multiclass_logloss_logits
}


class Ensemble:
    '''
    Ensemble with learned weights.
    
    Args:
      objective: optimization objective ('reg:mse', 'reg:mae',
        'binary:logloss_probs', 'binary:logloss_logits',
        'multi:logloss_probs', 'multi:logloss_logits')
      constraints: constraints for learned ensemble weights ('simplex',
        'nonnegative' or 'none')
      input_transform: transform for predictions input to ensemble
        (None, 'log').
      output_transform: transform for predictions generated by the ensemble
        (None, 'softmax', 'sigmoid')
      verbose: whether CVXPY solver should generate verbose output.
    '''

    def __init__(self,
                 objective,
                 constraints='simplex',
                 max_iters=100,
                 tolerance=1e-6,
                 verbose=False):
        # Verify objective and set solver
        assert objective in SOLVER_DICT.keys(), 'unrecognized solver'
        self.verbose = verbose
        self.solver = SOLVER_DICT[objective]
        
        # Verify constraints
        if objective in [
            'binary:logloss_probs',
            'multi:logloss_probs'
        ]:
            assert constraints in ['simplex']
        else:
            assert constraints in ['simplex', 'nonnegative', 'none']
        self.constraints = constraints
        
        # Set input/output transforms
        if objective == 'multi:logloss_logits':
            self.input_transform = utils.stable_log
            self.output_transform = utils.softmax
        elif objective == 'binary:logloss_logits':
            self.input_transform = utils.stable_logit
            self.output_transform = utils.sigmoid
        else:
            self.input_transform = None
            self.output_transform = None
            
        # For solver
        self.max_iters = max_iters
        self.tolerance = tolerance
    
    def fit(self, preds, targets):
        '''
        Fit the learned ensemble.
        
        Args:
          preds: an iterable (list, tuple) over each model's predictions.
          targets: prediction targets.
        '''
        # Apply input transform
        if self.input_transform:
            preds = [self.input_transform(preds) for preds in preds]

        # Find optimal weights
        self.weights = self.solver(list(preds), targets, self.constraints, self.verbose)
        return self

    def predict(self, preds):
        '''
        Apply the learned ensemble.
        
        Args:
          preds: an iterable (list, tuple) over each model's predictions.
        '''
        # Apply input transform
        if self.input_transform:
            preds = [self.input_transform(preds) for preds in preds]
            
        # Default to evenly weighted ensemble
        if not hasattr(self, 'weights'):
            print('Warning: defaulting to evenly weighted ensemble')
            self.weights = np.ones(len(preds)) / len(preds)
        
        # Apply learned ensemble
        return utils.apply_ensemble(
            list(preds), self.weights, self.output_transform)
