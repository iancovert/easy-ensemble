import numpy as np
from ensemble import cvxpy_solvers, utils


SOLVER_DICT = {
    'reg:mse': cvxpy_solvers.solve_regressor_mse,
    'reg:mae': cvxpy_solvers.solve_regressor_mae,
    'binary:logloss_probs': cvxpy_solvers.solve_binary_logloss_probs,
    'binary:logloss_logits': cvxpy_solvers.solve_binary_logloss_logits,
    'multi:logloss_probs': cvxpy_solvers.solve_multiclass_logloss_probs,
    'multi:logloss_logits': cvxpy_solvers.solve_multiclass_logloss_logits
}


class Ensemble:
    '''
    Ensemble with learned weights.
    
    Args:
      objective: optimization objective ('reg:mse', 'reg:mae',
        'binary:logloss_probs', 'binary:logloss_logits',
        'multi:logloss_probs', 'multi:logloss_logits')
      constraints: constraints for learned ensemble weights ('simplex',
        'nonnegative' or 'none')
      input_transform: transform for predictions input to ensemble
        (None, 'log').
      output_transform: transform for predictions generated by the ensemble
        (None, 'softmax', 'sigmoid')
      verbose: whether CVXPY solver should generate verbose output.
    '''

    def __init__(self,
                 objective,
                 constraints='simplex',
                 input_transform=None,
                 output_transform=None,
                 verbose=False):
        # Verify objective and set solver
        assert objective in SOLVER_DICT.keys(), 'unrecognized solver'
        self.verbose = verbose
        self.solver = SOLVER_DICT[objective]
        
        # Verify constraints
        if objective in [
            'binary:logloss_probs',
            'multi:logloss_probs'
        ]:
            assert constraints in ['simplex']
        else:
            assert constraints in ['simplex', 'nonnegative', 'none']
        self.constraints = constraints
        
        # Set input transform
        assert input_transform in [None, 'log', 'logit']
        if input_transform == 'log':
            assert objective in ['multi:logloss_logits']
            self.input_transform = utils.stable_log
        elif input_transform == 'logit':
            assert objective in ['binary:logloss_logits']
            self.input_transform = utils.stable_logit
        else:
            self.input_transform = None
        
        # Set output transform
        assert output_transform in [None, 'sigmoid', 'softmax']
        if output_transform == 'sigmoid':
            assert objective == 'binary:logloss_logits'
            self.output_transform = utils.sigmoid
        elif output_transform == 'softmax':
            assert objective == 'multi:logloss_logits'
            self.output_transform = utils.softmax
        else:
            self.output_transform = None
    
    def fit(self, preds_iterable, targets):
        '''
        Fit the learned ensemble.
        
        Args:
          preds_iterable: an iterable (e.g., list, tuple) over each model's
            predictions.
          targets: prediction targets.
        '''
        # Apply input transform
        if self.input_transform:
            preds_iterable = [self.input_transform(preds) for preds in preds_iterable]

        # Find optimal weights
        self.weights = self.solver(
            preds_iterable, targets, self.constraints, self.verbose)
        return self
    
    def predict(self, preds_iterable):
        '''
        Apply the learned ensemble.
        
        Args:
          preds_iterable: an iterable (e.g., list, tuple) over each model's
            predictions.
        '''
        # Apply input transform
        if self.input_transform:
            preds_iterable = [self.input_transform(preds) for preds in preds_iterable]
            
        # Default to evenly weighted ensemble
        if not hasattr(self, 'weights'):
            print('Warning: defaulting to evenly weighted ensemble')
            self.weights = np.ones(len(preds_iterable)) / len(preds_iterable)
        
        # Apply learned ensemble
        # TODO would be nice if this worked for PyTorch as well
        return utils.apply_ensemble(
            preds_iterable, self.weights, self.output_transform)
